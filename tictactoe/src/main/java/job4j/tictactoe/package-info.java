package job4j.tictactoe;

/**
 * Класс Figure3T - отвечает за клетку на поле.
 * Он содержит методы - имеет ли клетка крестик или нолик.
 * Или пустая.(не понятно как это выражается)
 *
 * Класс TicTacToe - реализует визуальный компонент.
 *
 * Класс Logic3T отвечает за проверку логики.
 * В этом задании нужно дореализовать эти методы.
 *
 * public boolean isWinnerX() - проверяет есть ли в
 * поле выигрышные комбинации для Крестика.
 *
 * public boolean isWinnerO() - проверяет есть ли
 * в поле выигрышные комбинации для Нолика.
 *
 * public boolean hasGap() - проверяет, если ли
 * пустые клетки для новых ходов.
 * Давайте сразу напишем тесты для проверки этой логики.
 *
 *
 * Logic3T
 * Как мы видим, то везде необходимо проверять последовательность. Единственное отличие это
 * в направлении движения следующего элемента.
 * Можно этот алгоритм выразить формулой - cell[x + deltaX][y + deltaY] == true.
 * Так же во всех 4 случаях у нас разная начальная точка.
 * Теперь давайте определить универсальный метод, который может вычислить
 * эти последовательности.
 * public boolean fillBy(Predicate<Figure3T> predicate, int startX, int startY, int deltaX, int deltaY);
 * Predicate<Figure3T> predicate - это параметризованное поведение. Мы его вводим, так как у нас два события: проверка на X и О.
 * int startX, startY - начальная точка
 * int deltaX, int deltaY - движения.
 * Для горизонтали движение будет по x, для вертикале по y, по диагонали движение должно быть и по x и по y.
 *
 * Давайте теперь реализуем этот метод.
 * this.fillBy(Figure3T::hasMarkX, 0, 2, 1, 0)
 * Figure3T::hasMarkX - это лябмда выражение означающее для каждого объекта Figure3T вызвать метод hasMarkX
 * Аналогично можно заменить для hasMarkY
 * Как его можно использовать.
 * public boolean isWinnerX() {
 *     return this.fillBy(Figure3T::hasMarkX, 0, 0, 1, 0) ||
 *             this.fillBy(Figure3T::hasMarkX, 0, 0, 0, 1) ||
 *             this.fillBy(Figure3T::hasMarkX, 0,0, 1, 1) ||
 *             this.fillBy(Figure3T::hasMarkX, this.table.length - 1 , 0, -1, 1);
 *
 */
